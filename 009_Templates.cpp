int minimum(int a, int b)
{
	if (a < b)
		return a;
	else
		return b;
}

double minimum(double a, double b)	//doubles are eight-bytes
{
	if (a < b)
		return a;
	else
		return b;
}

//we notice that the minimum implementations for doubles and ints are the same.
//let's try combine the functions implementations together

template<typename T>	//from now on, the pattern is represented as T and passed into the function
T minimum(T a, T b)
{
	if (a < b)
		return a;
	else
		return b;
}

//FUNCTION OVERLOAD DOES NOT REQUIRE template<>
//function overload for the template function: when char* is passed in it will automatically prefer this specialized function.
char* minimum(char* a, char* b)
{
	if (strcmp(a, b) < 0)
		return a;
	else
		return b;
}

int main()
{
	int k;
	cin >> k;
	cout << minimum(k, 10) / 2;	//k is int. Since we can replace T by int, we take in integers as the pattern for this specific function. A function that resembles the first int function above is generated by the compiler.
	double x;
	...
	double y = 3 * minimum(x*x, x + 10);	//x is double. We replace T by double.
	...
	int z = minimum(0, 3*k - k + 4);	//since the compiler-generated fnction for int is already initialized, we call that function directly.
	...

	int k;
	... minimum(k, 3.5)	... //error: k is int but 3.5 is double. the template T can only represent one type, and it cannot make implicit conversions. It does not match any template]
									//we can fix this issue by declaring a template with two members.
	chicken c1, c2;
	...
	chicken c3 = minimum(c1, c2);	//the compiler-generated function will not compile. We haven't defined the less than operator for Chicken type.
	...

	string s1, s2;
	string s3 = minimum(s1, s2);	//this compiles .. but...

	char ca1[100];
	char ca2[100];
	cin.getline(ca1, 100);
	cin.getline(ca2, 100);
	char* ca3 = minimum(ca1, ca2);
	...

	/*
	char* minimum(char* a, char* b)
	{
		if (a < b)
			return a;	this will compare the address memories of the first characters, and not the entire word!
		else
			return b;
	}
	*/

	//to resolve this problem, we can provide a speicific specialization template function for cstrings:

}

//template argument deduction - for a successful call to a template function:
	//1. the call matches some template
	//2. the instantiated template must compile.
	//3. The instantiated template must do what you want

//for matching, the only conversions considered for any type A are 
if the function wants	const A, A* or A&, its fine
//actual	//required type
A -> A&
A -> const A
array of A -> A*


//why we don't want this function to take in two different types
template<typename T1, typename T2>
??? minimum(T1 a, T2 b)
{
	if (a < b)
		return a;
	else
		return b;
}

int k;
cin >> k;
...minimum(k, 3.5);

template<typename T>
T sum(const T a[], int n)
{
	T total = T();	//initialize the array of any type
	for (int k = 0; k < n; k++)
		total += a[k];
	return total;
}

int main()
{
	double da[100];
	...
	cout << sum(da, 10);
	...

	string sa[10] = {}
}

class StackOfInt
{
public:
	StackOfInt();
	void push(int x);
	void pop();
	int top() const;
	int size() const;
private:
	int m_data[100];
	int m_top;
};

StackOfInt::StackOfInt()
	: m_top(0)
{}

void StackOfInt::push(int x)
{
	m_data[m_top] = x;	//undefined is full
	m_top++;
}

class StackOfDouble
{
public:
	StackOfInt();
	void push(double x);
	void pop();
	double top() const;
	int size() const;
private:
	double m_data[100];
	int m_top;
};

template<typename T>	//declare this above the class
class Stack
{
public:
	StackOfInt();
	void push(T x);
	void pop();
	T top() const;
	int size() const;
private:
	T m_data[100];
	int m_top;
};

template<typename T>	//always declare this line above any templated implementation
Stack<T>::Stack()	//always declare stack<>:: before each function. ALWAYS ADD <> when referring to the templated class
	: m_top(0)
	{}

template<typename T>
void Stack<T>::push(const T& x)
{
	m_data[m_top] = x;
	m_top++;
}


//if we are only attempting to access a variable, we would use const reference
template<typename T>
T minimum(const T& a, const T& b)
{
	return (a < b) ? a : b;
}

int main()
{
	ExpensiveToCopy x, y;
	...
	... minimum(x, y) ...;
	...
	int m, n;
	...
	... minimum(m, n) ...;
	...
}

ExpensiveToCopyThing minimum(ExpensiveToCopy a, ExpensiveToCopy b)
{
	return (a < b)	? a : b;
}

int minimum(int a, int b)
{
	return (a < b) ? a : b;
}


//not all types would compile in this template function
T sum(const T[] a, int n)
{
	T total = T();	//used to initialize a default value for all data types.
	for (int k = 0; k < n; k++)
		total += a[k];
	return total;
}

int main()
{
	double da[100];
	...
	cout << sum(da, 10);
	...
	string sa[10] = {
		"This", "is", "a", "test"
	};
	string s = sum(sa, 4);
}




